---
title: "CE TCR V5"
author: "Gabrielle Salamanca"
date: "Oct 19, 2025"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Libraries

```{r}
# data manipulation
library(dplyr)
library(psych)
library(readr)
library(readxl)
library(tidyr)

# visualize
library(factoextra)
library(ggfortify)
library(ggplot2)
library(gridExtra)

# techniques
library(brglm2) # bias-reduced log regress
library(caret) # data partition, CV
library(class) # KNN 
library(gbm) # boosting
library(MASS) # QDA & LDA
library(randomForest) # bag, rand forest
library(rpart) # class tree
library(stats)
library(tree) # regression tree
```

## Dataset

We read in the dataset, and replace a handful of NAs. The HD patients' Y and Y1 were filled in with "healthy", because Professor Tao confirmed they were healthy patients. Row 22 was removed, because there was confirmation that it didn't have any results, even in its own ID.

```{r}
gene <- read_excel("D:/Coding/R Storage/Summer TCR Project/TCR Datasets/2025/fullgenes.xlsx")

cat("The dimensions of the dataset is:")
dim(gene)

cat("\nAre there any NAs in the Y column?")
table(is.na(gene$Y))
cat("\nAre there NAs in the Y1 column?")
table(is.na(gene$Y1))

cat("\nWe remove row 22, to then have the dimensions:")
genedit <- gene[-22,]
dim(genedit)

cat("\n")

for (lab in intersect(c("Y","Y1"), names(genedit))) {
  genedit[[lab]][is.na(genedit[[lab]])] <- "healthy"
}

cat("After replacing NAs with the healthy tag, are there any lingering NAs in the Y column?")
table(is.na(genedit$Y))
cat("\nin the Y1 column?")
table(is.na(genedit$Y1))
```

## Training and Test Set

```{r}
set.seed(895)

train <- sample(1:nrow(genedit),0.8*nrow(genedit))
train.data <- genedit[train,]
test.data <- genedit[-train,]

cat("The dimensions of the training set is:", dim(train.data), "\n")
cat("The dimensions of the test is:", dim(test.data), "\n")

# turn Y binary
train.data$Y <- as.numeric(ifelse(train.data$Y == "disease", 1, 0))
test.data$Y  <- as.numeric(ifelse(test.data$Y  == "disease", 1, 0))
```

## Finding the Significant Genes

Prepping for the for loop:

```{r}
col <- ncol(train.data)
ycol <- match("Y", names(train.data))
gene_idx  <- 2:(col - 2)
gene.name <- names(train.data)[gene_idx]
pvalue <- numeric(length(gene_idx))
```

For loop to find the significant genes

```{r}
for (i in seq_along(gene_idx))
{
  gene_name <- gene.name[i]
  Xi <- train.data[, gene_idx[i], drop = FALSE]
  names(Xi) <- gene_name  # set column name to the gene
  
  dat <- data.frame(Y = train.data[[ycol]], Xi, 
                    check.names = FALSE)
  glm.fit <- glm(Y ~ ., data = dat, family = binomial())
  pvalue[i] <- coef(summary(glm.fit))[2, 4]
}
```

Create the results table and sort by significance

```{r}
# Combine results into a nice table:
results <- data.frame(Gene = gene.name, P_value = pvalue)

# Sort by significance
results <- results[order(results$P_value), ]
head(results)
```

Get only the genes that have a p-value less than 0.05, and make sure the genes are in both the training and test data

```{r}
alpha <- results[results$P_value < 0.05,]
cat("The dimensions of the significant genes (alpha) dataset is:")
dim(alpha)

ranked <- alpha$Gene
ranked <- intersect(ranked, intersect(names(train.data), names(test.data)))
```

Notes about the following lines of code in the upcoming techniques:

impute_from_train <- function(Xtr, Xte) {
  for (nm in colnames(Xtr)) {
    med <- median(Xtr[[nm]], na.rm = TRUE)
    if (is.finite(med)) {
      Xtr[[nm]][is.na(Xtr[[nm]])] <- med
      if (nm %in% colnames(Xte)) Xte[[nm]][is.na(Xte[[nm]])] <- med
    }
  }
  list(Xtr = Xtr, Xte = Xte)
}

This double checks for missing values in my training and test data. It will replace those with the median from the training data only, which prevents data leakage. Then it returns the cleaned versions of both sets.

This makes sure models like GLM, QDA, and LDA won't crash!

As for these lines of codes:

drop_nzv <- function(Xtr, Xte) {
  nzv <- vapply(Xtr, function(x) length(unique(na.omit(x))) > 1, logical(1))
  Xtr <- Xtr[, nzv, drop = FALSE]
  Xte <- Xte[, nzv, drop = FALSE]
  list(Xtr = Xtr, Xte = Xte)
}

They check if each significant gene are in my training set. If a gene has no variation, it will drop that column from both sets. This makes sure a zero-variance predictor won't contribute to the model. While not perfect, it's there just in case.

### GLM Fit

```{r}
steps <- seq(5, length(ranked), by = 5)

if (length(ranked) > 0 && tail(steps, 1) != length(ranked)) {
  steps <- c(steps, length(ranked))
}
```

Calculating test accuracy of the glm fits in increments of 5 (5 -> 10 -> ... -> 37)

```{r}
glm_curve <- data.frame(TopGenes = integer(), Test_Acc = numeric())

for (k in steps) {
  genes_k <- ranked[1:k]

  Xi_tr <- as.data.frame(train.data[, genes_k, drop = FALSE])
  Xi_te <- as.data.frame(test.data[,  genes_k, drop = FALSE])

  # Impute NAs in test with TRAIN medians (per feature)
  for (nm in colnames(Xi_tr)) {
    med <- median(Xi_tr[[nm]], na.rm = TRUE)
    if (is.finite(med)) {
      Xi_tr[[nm]][is.na(Xi_tr[[nm]])] <- med
      Xi_te[[nm]][is.na(Xi_te[[nm]])] <- med
    }
  }

  # Drop zero-variance predictors
  nzv <- vapply(Xi_tr, function(x) length(unique(na.omit(x))) > 1, logical(1))
  Xi_tr <- Xi_tr[, nzv, drop = FALSE]
  Xi_te <- Xi_te[, nzv, drop = FALSE]
  if (ncol(Xi_tr) == 0L) {
    glm_curve <- rbind(glm_curve, data.frame(TopGenes = k, Test_Acc = NA))
    next
  }

  # build modeling frames
  dat_tr <- data.frame(Y = train.data$Y, Xi_tr, check.names = FALSE)
  dat_te <- data.frame(Y = test.data$Y,  Xi_te,  check.names = FALSE)
  
  # Make Y a 2-level factor (most robust for binomial)
  dat_tr$Y <- factor(dat_tr$Y, levels = c(0, 1))
  dat_te$Y <- factor(dat_te$Y, levels = levels(dat_tr$Y))
  
  
  # Separation-safe GLM (brglm2)
  
  fit <- tryCatch(glm(Y ~ ., data = dat_tr, 
                      family = binomial(link = "logit"), 
                      method = brglm2::brglmFit),
                  error = function(e) NULL)

  if (is.null(fit)) {
    glm_curve <- rbind(glm_curve, data.frame(TopGenes = k, 
                                             Test_Acc = NA))
  next
    }
  
  prob <- predict(fit, newdata = dat_te, type = "response")
  pred <- ifelse(prob > 0.5, 1, 0)
  acc  <- mean(pred == dat_te$Y)

  cat("Top", k, "→ Test Acc:", sprintf("%.4f", acc), "\n")
  glm_curve <- rbind(glm_curve, data.frame(TopGenes = k, 
                                           Test_Acc = acc))
}
```

## QDA

Prepping for QDA

```{r}
# 2-lvl factor in both sets
train.data$Y <- factor(train.data$Y, levels = c(0,1))
test.data$Y  <- factor(test.data$Y,  levels = levels(train.data$Y))

# made sure to run through all the genes
max_k <- min(37L, length(ranked))
if (max_k < 5L) max_k <- length(ranked)  # if you have <5 genes, just do that many
steps <- seq(5L, max_k, by = 5L)
if (tail(steps, 1) != max_k) steps <- c(steps, max_k)

# impute NAs in both train/test using TRAIN medians 
impute_from_train <- function(Xtr, Xte) {
  for (nm in colnames(Xtr)) {
    med <- median(Xtr[[nm]], na.rm = TRUE)
    if (is.finite(med)) {
      Xtr[[nm]][is.na(Xtr[[nm]])] <- med
      if (nm %in% colnames(Xte)) Xte[[nm]][is.na(Xte[[nm]])] <- med
    }
  }
  list(Xtr = Xtr, Xte = Xte)
}

# drop 0-var cols
drop_nzv <- function(Xtr, Xte) {
  nzv <- vapply(Xtr, function(x) length(unique(na.omit(x))) > 1, logical(1))
  Xtr <- Xtr[, nzv, drop = FALSE]
  Xte <- Xte[, nzv, drop = FALSE]
  list(Xtr = Xtr, Xte = Xte)
}

# storage
qda_curve  <- data.frame(TopGenes = integer(), Test_Acc = numeric())
qda_models <- vector("list", length(steps))
names(qda_models) <- paste0("top_", steps)
```

Running QDA

```{r}
for (s in seq_along(steps)) {
  k <- steps[s]
  genes_k <- ranked[1:k]

  Xtr <- as.data.frame(train.data[, genes_k, drop = FALSE])
  Xte <- as.data.frame(test.data[,  genes_k, drop = FALSE])

  tmp <- impute_from_train(Xtr, Xte); Xtr <- tmp$Xtr; Xte <- tmp$Xte
  tmp <- drop_nzv(Xtr, Xte);          Xtr <- tmp$Xtr; Xte <- tmp$Xte
  if (ncol(Xtr) == 0L) {
    qda_curve <- rbind(qda_curve, data.frame(TopGenes = k, Test_Acc = NA_real_))
    next
  }

  dat_tr <- data.frame(Y = train.data$Y, Xtr, check.names = FALSE)
  dat_te <- data.frame(Y = test.data$Y,  Xte, check.names = FALSE)

  qda.fit <- tryCatch(qda(Y ~ ., data = dat_tr),
                      error = function(e) { warning("top_", k, ": ", e$message); NULL })
  if (is.null(qda.fit)) {
    qda_curve <- rbind(qda_curve, data.frame(TopGenes = k, Test_Acc = NA_real_))
    next
  }

  qda_models[[s]] <- qda.fit
  pred_test <- predict(qda.fit, newdata = dat_te)$class
  acc <- mean(pred_test == dat_te$Y)
  cat("Top", k, "→ Test Acc:", sprintf("%.4f", acc), "\n")

  qda_curve <- rbind(qda_curve, data.frame(TopGenes = k, Test_Acc = acc))
}
```

## LDA

Prepping for LDA

```{r}
train.data$Y <- factor(train.data$Y, levels = c(0,1))
test.data$Y  <- factor(test.data$Y,  levels = levels(train.data$Y))

# helpers
impute_from_train <- function(Xtr, Xte) {
  for (nm in colnames(Xtr)) {
    med <- median(Xtr[[nm]], na.rm = TRUE)
    if (is.finite(med)) {
      Xtr[[nm]][is.na(Xtr[[nm]])] <- med
      if (nm %in% colnames(Xte)) Xte[[nm]][is.na(Xte[[nm]])] <- med
    }
  }
  list(Xtr = Xtr, Xte = Xte)
}
drop_nzv <- function(Xtr, Xte) {
  nzv <- vapply(Xtr, function(x) length(unique(na.omit(x))) > 1, logical(1))
  Xtr <- Xtr[, nzv, drop = FALSE]
  Xte <- Xte[, nzv, drop = FALSE]
  list(Xtr = Xtr, Xte = Xte)
}

# lda prep
lda_curve  <- data.frame(TopGenes = integer(), Test_Acc = numeric())
lda_models <- vector("list", length(steps))
names(lda_models) <- paste0("top_", steps)
```

LDA for loop

```{r}
for (s in seq_along(steps)) {
  k <- steps[s]
  genes_k <- ranked[1:k]

  Xtr <- as.data.frame(train.data[, genes_k, drop = FALSE])
  Xte <- as.data.frame(test.data[,  genes_k, drop = FALSE])

  # impute NAs (from TRAIN medians) + drop zero-variance
  tmp <- impute_from_train(Xtr, Xte); Xtr <- tmp$Xtr; Xte <- tmp$Xte
  tmp <- drop_nzv(Xtr, Xte);          Xtr <- tmp$Xtr; Xte <- tmp$Xte
  if (ncol(Xtr) == 0L) {
    lda_curve <- rbind(lda_curve, data.frame(TopGenes = k, 
                                             Test_Acc = NA_real_))
    next
  }

  dat_tr <- data.frame(Y = train.data$Y, Xtr, check.names = FALSE)
  dat_te <- data.frame(Y = test.data$Y,  Xte, check.names = FALSE)

  lda.fit <- tryCatch(lda(Y ~ ., data = dat_tr),
                      error = function(e) 
                        { warning("top_", k, ": ", e$message); NULL })
  
  if (is.null(lda.fit)) {
    lda_curve <- rbind(lda_curve, data.frame(TopGenes = k, 
                                             Test_Acc = NA_real_))
    next
  }

  lda_models[[s]] <- lda.fit
  pred_test <- predict(lda.fit, newdata = dat_te)$class
  acc <- mean(pred_test == dat_te$Y)
  cat("Top", k, "→ LDA Test Acc:", sprintf("%.4f", acc), "\n")

  lda_curve <- rbind(lda_curve, data.frame(TopGenes = k, Test_Acc = acc))
}
```

## KNN

KNN Prep

```{r}
train.data$Y <- factor(train.data$Y, levels = c(0,1))
test.data$Y  <- factor(test.data$Y,  levels = levels(train.data$Y))

# k
k1 <- 3
k2 <- 5
k3 <- 7
cat("We will test out these k's:", k1, ",", k2, ",", k3)

knn_curve <- data.frame(TopGenes = integer(), k = integer(), 
                        Test_Acc = numeric())
```

KNN for loop: k = 3

```{r}
for (m in steps) {
  genes_m <- ranked[1:m]

  Xtr <- as.data.frame(train.data[, genes_m, drop = FALSE])
  Xte <- as.data.frame(test.data[,  genes_m, drop = FALSE])
  ytr <- train.data$Y
  yte <- test.data$Y

  # --- Impute NAs with TRAIN medians (per feature) ---
  for (nm in colnames(Xtr)) {
    med <- median(Xtr[[nm]], na.rm = TRUE)
    if (is.finite(med)) {
      Xtr[[nm]][is.na(Xtr[[nm]])] <- med
      Xte[[nm]][is.na(Xte[[nm]])] <- med
    }
  }

  # --- Drop zero-variance columns (after impute) ---
  nzv <- vapply(Xtr, function(x) length(unique(na.omit(x))) > 1, logical(1))
  if (!any(nzv)) {
    knn_curve <- rbind(knn_curve, data.frame(TopGenes = m, k = k1, 
                                             Test_Acc = NA_real_))
    next
  }
  Xtr <- Xtr[, nzv, drop = FALSE]
  Xte <- Xte[, nzv, drop = FALSE]

  # --- Standardize using TRAIN mean/sd (critical for KNN) ---
  mu  <- vapply(Xtr, mean, numeric(1), na.rm = TRUE)
  sdx <- vapply(Xtr, sd,   numeric(1), na.rm = TRUE); sdx[sdx == 0] <- 1
  Xtr_sc <- scale(Xtr, center = mu, scale = sdx)
  Xte_sc <- scale(Xte, center = mu, scale = sdx)

  # --- KNN prediction on TEST ONLY ---
  pred <- knn(train = Xtr_sc, test = Xte_sc, cl = ytr, k = k1)
  acc  <- mean(pred == yte)

  cat("Top", m, "genes  →  K =", k1, "  Test Acc:", 
      sprintf("%.4f", acc), "\n")
  knn_curve <- rbind(knn_curve, data.frame(TopGenes = m, k = k1, 
                                           Test_Acc = acc))
}
```

KNN for loop: k = 5

```{r}
for (m in steps) {
  genes_m <- ranked[1:m]

  Xtr <- as.data.frame(train.data[, genes_m, drop = FALSE])
  Xte <- as.data.frame(test.data[,  genes_m, drop = FALSE])
  ytr <- train.data$Y
  yte <- test.data$Y

  # --- Impute NAs with TRAIN medians (per feature) ---
  for (nm in colnames(Xtr)) {
    med <- median(Xtr[[nm]], na.rm = TRUE)
    if (is.finite(med)) {
      Xtr[[nm]][is.na(Xtr[[nm]])] <- med
      Xte[[nm]][is.na(Xte[[nm]])] <- med
    }
  }

  # --- Drop zero-variance columns (after impute) ---
  nzv <- vapply(Xtr, function(x) length(unique(na.omit(x))) > 1, logical(1))
  if (!any(nzv)) {
    knn_curve <- rbind(knn_curve, data.frame(TopGenes = m, k = k2, 
                                             Test_Acc = NA_real_))
    next
  }
  Xtr <- Xtr[, nzv, drop = FALSE]
  Xte <- Xte[, nzv, drop = FALSE]

  # --- Standardize using TRAIN mean/sd (critical for KNN) ---
  mu  <- vapply(Xtr, mean, numeric(1), na.rm = TRUE)
  sdx <- vapply(Xtr, sd,   numeric(1), na.rm = TRUE); sdx[sdx == 0] <- 1
  Xtr_sc <- scale(Xtr, center = mu, scale = sdx)
  Xte_sc <- scale(Xte, center = mu, scale = sdx)

  # --- KNN prediction on TEST ONLY ---
  pred <- knn(train = Xtr_sc, test = Xte_sc, cl = ytr, k = k2)
  acc  <- mean(pred == yte)

  cat("Top", m, "genes  →  K =", k2, "  Test Acc:", 
      sprintf("%.4f", acc), "\n")
  knn_curve <- rbind(knn_curve, data.frame(TopGenes = m, k = k2, 
                                           Test_Acc = acc))
}
```

KNN for loop: k = 7

```{r}
for (m in steps) {
  genes_m <- ranked[1:m]

  Xtr <- as.data.frame(train.data[, genes_m, drop = FALSE])
  Xte <- as.data.frame(test.data[,  genes_m, drop = FALSE])
  ytr <- train.data$Y
  yte <- test.data$Y

  # --- Impute NAs with TRAIN medians (per feature) ---
  for (nm in colnames(Xtr)) {
    med <- median(Xtr[[nm]], na.rm = TRUE)
    if (is.finite(med)) {
      Xtr[[nm]][is.na(Xtr[[nm]])] <- med
      Xte[[nm]][is.na(Xte[[nm]])] <- med
    }
  }

  # --- Drop zero-variance columns (after impute) ---
  nzv <- vapply(Xtr, function(x) length(unique(na.omit(x))) > 1, logical(1))
  if (!any(nzv)) {
    knn_curve <- rbind(knn_curve, data.frame(TopGenes = m, k = k3, 
                                             Test_Acc = NA_real_))
    next
  }
  Xtr <- Xtr[, nzv, drop = FALSE]
  Xte <- Xte[, nzv, drop = FALSE]

  # --- Standardize using TRAIN mean/sd (critical for KNN) ---
  mu  <- vapply(Xtr, mean, numeric(1), na.rm = TRUE)
  sdx <- vapply(Xtr, sd,   numeric(1), na.rm = TRUE); sdx[sdx == 0] <- 1
  Xtr_sc <- scale(Xtr, center = mu, scale = sdx)
  Xte_sc <- scale(Xte, center = mu, scale = sdx)

  # --- KNN prediction on TEST ONLY ---
  pred <- knn(train = Xtr_sc, test = Xte_sc, cl = ytr, k = k3)
  acc  <- mean(pred == yte)

  cat("Top", m, "genes  →  K =", k3, "  Test Acc:", 
      sprintf("%.4f", acc), "\n")
  knn_curve <- rbind(knn_curve, data.frame(TopGenes = m, k = k3, 
                                           Test_Acc = acc))
}
```

## Classification Tree

Prepping for classification tree (trying with just top 5, running into problems with going thru the dataset)

```{r}
train.data$Y <- factor(train.data$Y, levels = c(0,1))
test.data$Y  <- factor(test.data$Y,  levels = levels(train.data$Y))
# top 5
genes5 <- alpha[order(alpha$P_value), "Gene"]
genes5 <- genes5[genes5 %in% names(train.data)]
genes5 <- intersect(genes5, names(test.data))
genes5 <- genes5[!duplicated(genes5)]

if (length(genes5) < 5) {
  warning("Fewer than 5 alpha genes available in both train & test; using ", length(genes5))
}
genes5 <- genes5[1:min(5, length(genes5))]
stopifnot(length(genes5) > 0)

# prevent leakage
Xtr <- as.data.frame(train.data[, genes5, drop = FALSE])
Xte <- as.data.frame(test.data[,  genes5, drop = FALSE])
```

For loop: Need to debug

```{r}
for (s in seq_along(steps)) {
  k <- steps[s]
  genes_k <- ranked[1:k]

  # Extract predictors
  Xtr <- as.data.frame(train.data[, genes_k, drop = FALSE])
  Xte <- as.data.frame(test.data[,  genes_k, drop = FALSE])

  # Impute NAs (training medians → applied to test)
  tmp <- impute_from_train(Xtr, Xte)
  Xtr <- tmp$Xtr
  Xte <- tmp$Xte

  # Sanitize column names for formula safety
  safe_names <- make.names(genes_k, unique = TRUE)
  colnames(Xtr) <- safe_names
  colnames(Xte) <- safe_names

  # Modeling data (Y + predictors)
  dat_tr <- data.frame(Y = train.data$Y, 
                       Xtr[, safe_names, drop = FALSE], 
                       check.names = FALSE)
  dat_te <- data.frame(Y = test.data$Y,  
                       Xte[, safe_names, drop = FALSE], 
                       check.names = FALSE)

  # Formula using same names
  form_tree <- as.formula(paste("Y ~", paste(safe_names, 
                                             collapse = " + ")))

  # Fit classification tree + CV pruning
  fit <- tryCatch(
    rpart(form_tree, data = dat_tr, method = "class",
          control = rpart.control(cp = 0.001, 
                                  minsplit = 10, xval = 10)),
    error = function(e) NULL
  )
  if (is.null(fit)) {
    tree_curve <- rbind(tree_curve, 
                        data.frame(TopGenes = k, 
                                   Test_Error = NA_real_))
    next
  }

  # Prune using optimal cp (smallest cross-validation error)
  cp_opt <- with(fit$cptable, CP[which.min(xerror)])
  fit_pruned <- prune(fit, cp = cp_opt)
  tree_models[[s]] <- fit_pruned

  # Predict on test data + compute test error
  pred <- predict(fit_pruned, newdata = dat_te, type = "class")
  test_error <- mean(pred != dat_te$Y)

  cat("Top", k, "→ Test Error:", sprintf("%.4f", test_error),
      "  (cp* =", signif(cp_opt, 3), ")\n")

  tree_curve <- rbind(tree_curve, 
                      data.frame(TopGenes = k, 
                                 Test_Error = test_error))
}
```


```{r, ref.label=knitr::all_labels(), echo = TRUE, eval = FALSE}
```