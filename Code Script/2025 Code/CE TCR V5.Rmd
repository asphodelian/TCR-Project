---
title: "CE TCR V5"
author: "Gabrielle Salamanca"
date: "Oct 19, 2025"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Libraries

```{r}
library(class)
library(dplyr)
library(factoextra)
library(ggfortify)
library(ggplot2)
library(gridExtra)
library(psych)
library(readr)
library(readxl)
library(tidyr)

library(brglm2)
library(caret)
library(class) # KNN 
library(gbm)
library(MASS) # QDA & LDA
library(randomForest)
library(stats)
library(tree) # regression tree
```

## Dataset

We read in the dataset, and replace a handful of NAs. The HD patients' Y and Y1 were filled in with "healthy", because Professor Tao confirmed they were healthy patients. Row 22 was removed, because there was confirmation that it didn't have any results, even in its own ID.

```{r}
gene <- read_excel("D:/Coding/R Storage/Summer TCR Project/TCR Datasets/2025/fullgenes.xlsx")

cat("The dimensions of the dataset is:")
dim(gene)

cat("\nAre there any NAs in the Y column?")
table(is.na(gene$Y))
cat("\nAre there NAs in the Y1 column?")
table(is.na(gene$Y1))

cat("\nWe remove row 22, to then have the dimensions:")
genedit <- gene[-22,]
dim(genedit)

cat("\n")

for (lab in intersect(c("Y","Y1"), names(genedit))) {
  genedit[[lab]][is.na(genedit[[lab]])] <- "healthy"
}

cat("After replacing NAs with the healthy tag, are there any lingering NAs in the Y column?")
table(is.na(genedit$Y))
cat("\nin the Y1 column?")
table(is.na(genedit$Y1))
```

## Training and Test Set

```{r}
set.seed(895)

train <- sample(1:nrow(genedit),0.8*nrow(genedit))
train.data <- genedit[train,]
test.data <- genedit[-train,]

cat("The dimensions of the training set is:", dim(train.data), "\n")
cat("The dimensions of the test is:", dim(test.data), "\n")

# turn Y binary
train.data$Y <- as.numeric(ifelse(train.data$Y == "disease", 1, 0))
test.data$Y  <- as.numeric(ifelse(test.data$Y  == "disease", 1, 0))
```

## Finding the Significant Genes

Prepping for the for loop:

```{r}
col <- ncol(train.data)
ycol <- match("Y", names(train.data))
gene_idx  <- 2:(col - 2)
gene.name <- names(train.data)[gene_idx]
pvalue <- numeric(length(gene_idx))
```

For loop to find the significant genes

```{r}
for (i in seq_along(gene_idx))
{
  gene_name <- gene.name[i]
  Xi <- train.data[, gene_idx[i], drop = FALSE]
  names(Xi) <- gene_name  # set column name to the gene
  
  dat <- data.frame(Y = train.data[[ycol]], Xi, check.names = FALSE)
  glm.fit <- glm(Y ~ ., data = dat, family = binomial())
  pvalue[i] <- coef(summary(glm.fit))[2, 4]
}
```

Create the results table and sort by significance

```{r}
# Combine results into a nice table:
results <- data.frame(Gene = gene.name, P_value = pvalue)

# Sort by significance
results <- results[order(results$P_value), ]
head(results)
```

Get only the genes that have a p-value less than 0.05, and make sure the genes are in both the training and test data

```{r}
alpha <- results[results$P_value < 0.05,]
cat("The dimensions of the significant genes (alpha) dataset is:")
dim(alpha)

ranked <- alpha$Gene
ranked <- intersect(ranked, intersect(names(train.data), names(test.data)))
```

Notes about the following lines of code in the upcoming techniques:

impute_from_train <- function(Xtr, Xte) {
  for (nm in colnames(Xtr)) {
    med <- median(Xtr[[nm]], na.rm = TRUE)
    if (is.finite(med)) {
      Xtr[[nm]][is.na(Xtr[[nm]])] <- med
      if (nm %in% colnames(Xte)) Xte[[nm]][is.na(Xte[[nm]])] <- med
    }
  }
  list(Xtr = Xtr, Xte = Xte)
}

This double checks for missing values in my training and test data. It will replace those with the median from the training data only, which prevents data leakage. Then it returns the cleaned versions of both sets.

This makes sure models like GLM, QDA, and LDA won't crash!

As for these lines of codes:

drop_nzv <- function(Xtr, Xte) {
  nzv <- vapply(Xtr, function(x) length(unique(na.omit(x))) > 1, logical(1))
  Xtr <- Xtr[, nzv, drop = FALSE]
  Xte <- Xte[, nzv, drop = FALSE]
  list(Xtr = Xtr, Xte = Xte)
}

They check if each significant gene are in my training set. If a gene has no variation, it will drop that column from both sets. This makes sure a zero-variance predictor won't contribute to the model. While not perfect, it's there just in case.

### GLM Fit

```{r}
steps <- seq(5, length(ranked), by = 5)

if (length(ranked) > 0 && tail(steps, 1) != length(ranked)) {
  steps <- c(steps, length(ranked))
}
```

Calculating test accuracy of the glm fits in increments of 5 (5 -> 10 -> ... -> 37)

```{r}
glm_curve <- data.frame(TopGenes = integer(), Test_Acc = numeric())

for (k in steps) {
  genes_k <- ranked[1:k]

  Xi_tr <- as.data.frame(train.data[, genes_k, drop = FALSE])
  Xi_te <- as.data.frame(test.data[,  genes_k, drop = FALSE])

  # Impute NAs in test with TRAIN medians (per feature)
  for (nm in colnames(Xi_tr)) {
    med <- median(Xi_tr[[nm]], na.rm = TRUE)
    if (is.finite(med)) {
      Xi_tr[[nm]][is.na(Xi_tr[[nm]])] <- med
      Xi_te[[nm]][is.na(Xi_te[[nm]])] <- med
    }
  }

  # Drop zero-variance predictors
  nzv <- vapply(Xi_tr, function(x) length(unique(na.omit(x))) > 1, logical(1))
  Xi_tr <- Xi_tr[, nzv, drop = FALSE]
  Xi_te <- Xi_te[, nzv, drop = FALSE]
  if (ncol(Xi_tr) == 0L) {
    glm_curve <- rbind(glm_curve, data.frame(TopGenes = k, Test_Acc = NA))
    next
  }

  # build modeling frames
  dat_tr <- data.frame(Y = train.data$Y, Xi_tr, check.names = FALSE)
  dat_te <- data.frame(Y = test.data$Y,  Xi_te,  check.names = FALSE)
  
  # Make Y a 2-level factor (most robust for binomial)
  dat_tr$Y <- factor(dat_tr$Y, levels = c(0, 1))
  dat_te$Y <- factor(dat_te$Y, levels = levels(dat_tr$Y))
  
  
  # Separation-safe GLM (brglm2)
  
  fit <- tryCatch(glm(Y ~ ., data = dat_tr, 
                      family = binomial(link = "logit"), 
                      method = brglm2::brglmFit),
                  error = function(e) NULL)

  if (is.null(fit)) {
    glm_curve <- rbind(glm_curve, data.frame(TopGenes = k, 
                                             Test_Acc = NA))
  next
    }
  
  prob <- predict(fit, newdata = dat_te, type = "response")
  pred <- ifelse(prob > 0.5, 1, 0)
  acc  <- mean(pred == dat_te$Y)

  cat("Top", k, "→ Test Acc:", sprintf("%.4f", acc), "\n")
  glm_curve <- rbind(glm_curve, data.frame(TopGenes = k, 
                                           Test_Acc = acc))
}
```

## QDA

Prepping for QDA

```{r}
# 2-lvl factor in both sets
train.data$Y <- factor(train.data$Y, levels = c(0,1))
test.data$Y  <- factor(test.data$Y,  levels = levels(train.data$Y))

# made sure to run through all the genes
max_k <- min(37L, length(ranked))
if (max_k < 5L) max_k <- length(ranked)  # if you have <5 genes, just do that many
steps <- seq(5L, max_k, by = 5L)
if (tail(steps, 1) != max_k) steps <- c(steps, max_k)

# impute NAs in both train/test using TRAIN medians 
impute_from_train <- function(Xtr, Xte) {
  for (nm in colnames(Xtr)) {
    med <- median(Xtr[[nm]], na.rm = TRUE)
    if (is.finite(med)) {
      Xtr[[nm]][is.na(Xtr[[nm]])] <- med
      if (nm %in% colnames(Xte)) Xte[[nm]][is.na(Xte[[nm]])] <- med
    }
  }
  list(Xtr = Xtr, Xte = Xte)
}

# drop 0-var cols
drop_nzv <- function(Xtr, Xte) {
  nzv <- vapply(Xtr, function(x) length(unique(na.omit(x))) > 1, logical(1))
  Xtr <- Xtr[, nzv, drop = FALSE]
  Xte <- Xte[, nzv, drop = FALSE]
  list(Xtr = Xtr, Xte = Xte)
}

# storage
qda_curve  <- data.frame(TopGenes = integer(), Test_Acc = numeric())
qda_models <- vector("list", length(steps))
names(qda_models) <- paste0("top_", steps)
```

Running QDA

```{r}
for (s in seq_along(steps)) {
  k <- steps[s]
  genes_k <- ranked[1:k]

  Xtr <- as.data.frame(train.data[, genes_k, drop = FALSE])
  Xte <- as.data.frame(test.data[,  genes_k, drop = FALSE])

  tmp <- impute_from_train(Xtr, Xte); Xtr <- tmp$Xtr; Xte <- tmp$Xte
  tmp <- drop_nzv(Xtr, Xte);          Xtr <- tmp$Xtr; Xte <- tmp$Xte
  if (ncol(Xtr) == 0L) {
    qda_curve <- rbind(qda_curve, data.frame(TopGenes = k, Test_Acc = NA_real_))
    next
  }

  dat_tr <- data.frame(Y = train.data$Y, Xtr, check.names = FALSE)
  dat_te <- data.frame(Y = test.data$Y,  Xte, check.names = FALSE)

  qda.fit <- tryCatch(qda(Y ~ ., data = dat_tr),
                      error = function(e) { warning("top_", k, ": ", e$message); NULL })
  if (is.null(qda.fit)) {
    qda_curve <- rbind(qda_curve, data.frame(TopGenes = k, Test_Acc = NA_real_))
    next
  }

  qda_models[[s]] <- qda.fit
  pred_test <- predict(qda.fit, newdata = dat_te)$class
  acc <- mean(pred_test == dat_te$Y)
  cat("Top", k, "→ Test Acc:", sprintf("%.4f", acc), "\n")

  qda_curve <- rbind(qda_curve, data.frame(TopGenes = k, Test_Acc = acc))
}
```

## LDA

Prepping for LDA

```{r}
train.data$Y <- factor(train.data$Y, levels = c(0,1))
test.data$Y  <- factor(test.data$Y,  levels = levels(train.data$Y))

# helpers
impute_from_train <- function(Xtr, Xte) {
  for (nm in colnames(Xtr)) {
    med <- median(Xtr[[nm]], na.rm = TRUE)
    if (is.finite(med)) {
      Xtr[[nm]][is.na(Xtr[[nm]])] <- med
      if (nm %in% colnames(Xte)) Xte[[nm]][is.na(Xte[[nm]])] <- med
    }
  }
  list(Xtr = Xtr, Xte = Xte)
}
drop_nzv <- function(Xtr, Xte) {
  nzv <- vapply(Xtr, function(x) length(unique(na.omit(x))) > 1, logical(1))
  Xtr <- Xtr[, nzv, drop = FALSE]
  Xte <- Xte[, nzv, drop = FALSE]
  list(Xtr = Xtr, Xte = Xte)
}

# lda prep
lda_curve  <- data.frame(TopGenes = integer(), Test_Acc = numeric())
lda_models <- vector("list", length(steps))
names(lda_models) <- paste0("top_", steps)
```

LDA for loop

```{r}
for (s in seq_along(steps)) {
  k <- steps[s]
  genes_k <- ranked[1:k]

  Xtr <- as.data.frame(train.data[, genes_k, drop = FALSE])
  Xte <- as.data.frame(test.data[,  genes_k, drop = FALSE])

  # impute NAs (from TRAIN medians) + drop zero-variance
  tmp <- impute_from_train(Xtr, Xte); Xtr <- tmp$Xtr; Xte <- tmp$Xte
  tmp <- drop_nzv(Xtr, Xte);          Xtr <- tmp$Xtr; Xte <- tmp$Xte
  if (ncol(Xtr) == 0L) {
    lda_curve <- rbind(lda_curve, data.frame(TopGenes = k, 
                                             Test_Acc = NA_real_))
    next
  }

  dat_tr <- data.frame(Y = train.data$Y, Xtr, check.names = FALSE)
  dat_te <- data.frame(Y = test.data$Y,  Xte, check.names = FALSE)

  lda.fit <- tryCatch(lda(Y ~ ., data = dat_tr),
                      error = function(e) 
                        { warning("top_", k, ": ", e$message); NULL })
  
  if (is.null(lda.fit)) {
    lda_curve <- rbind(lda_curve, data.frame(TopGenes = k, 
                                             Test_Acc = NA_real_))
    next
  }

  lda_models[[s]] <- lda.fit
  pred_test <- predict(lda.fit, newdata = dat_te)$class
  acc <- mean(pred_test == dat_te$Y)
  cat("Top", k, "→ LDA Test Acc:", sprintf("%.4f", acc), "\n")

  lda_curve <- rbind(lda_curve, data.frame(TopGenes = k, Test_Acc = acc))
}
```

## KNN

KNN Prep

```{r}
train.data$Y <- factor(train.data$Y, levels = c(0,1))
test.data$Y  <- factor(test.data$Y,  levels = levels(train.data$Y))

# k
k1 <- 3
k2 <- 5
k3 <- 7
cat("We will test out these k's:", k1, ",", k2, ",", k3)

knn_curve <- data.frame(TopGenes = integer(), k = integer(), 
                        Test_Acc = numeric())
```

KNN for loop: k = 3

```{r}
for (m in steps) {
  genes_m <- ranked[1:m]

  Xtr <- as.data.frame(train.data[, genes_m, drop = FALSE])
  Xte <- as.data.frame(test.data[,  genes_m, drop = FALSE])
  ytr <- train.data$Y
  yte <- test.data$Y

  # --- Impute NAs with TRAIN medians (per feature) ---
  for (nm in colnames(Xtr)) {
    med <- median(Xtr[[nm]], na.rm = TRUE)
    if (is.finite(med)) {
      Xtr[[nm]][is.na(Xtr[[nm]])] <- med
      Xte[[nm]][is.na(Xte[[nm]])] <- med
    }
  }

  # --- Drop zero-variance columns (after impute) ---
  nzv <- vapply(Xtr, function(x) length(unique(na.omit(x))) > 1, logical(1))
  if (!any(nzv)) {
    knn_curve <- rbind(knn_curve, data.frame(TopGenes = m, k = k1, 
                                             Test_Acc = NA_real_))
    next
  }
  Xtr <- Xtr[, nzv, drop = FALSE]
  Xte <- Xte[, nzv, drop = FALSE]

  # --- Standardize using TRAIN mean/sd (critical for KNN) ---
  mu  <- vapply(Xtr, mean, numeric(1), na.rm = TRUE)
  sdx <- vapply(Xtr, sd,   numeric(1), na.rm = TRUE); sdx[sdx == 0] <- 1
  Xtr_sc <- scale(Xtr, center = mu, scale = sdx)
  Xte_sc <- scale(Xte, center = mu, scale = sdx)

  # --- KNN prediction on TEST ONLY ---
  pred <- knn(train = Xtr_sc, test = Xte_sc, cl = ytr, k = k1)
  acc  <- mean(pred == yte)

  cat("Top", m, "genes  →  K =", k1, "  Test Acc:", 
      sprintf("%.4f", acc), "\n")
  knn_curve <- rbind(knn_curve, data.frame(TopGenes = m, k = k1, 
                                           Test_Acc = acc))
}
```

KNN for loop: k = 5

```{r}
for (m in steps) {
  genes_m <- ranked[1:m]

  Xtr <- as.data.frame(train.data[, genes_m, drop = FALSE])
  Xte <- as.data.frame(test.data[,  genes_m, drop = FALSE])
  ytr <- train.data$Y
  yte <- test.data$Y

  # --- Impute NAs with TRAIN medians (per feature) ---
  for (nm in colnames(Xtr)) {
    med <- median(Xtr[[nm]], na.rm = TRUE)
    if (is.finite(med)) {
      Xtr[[nm]][is.na(Xtr[[nm]])] <- med
      Xte[[nm]][is.na(Xte[[nm]])] <- med
    }
  }

  # --- Drop zero-variance columns (after impute) ---
  nzv <- vapply(Xtr, function(x) length(unique(na.omit(x))) > 1, logical(1))
  if (!any(nzv)) {
    knn_curve <- rbind(knn_curve, data.frame(TopGenes = m, k = k2, 
                                             Test_Acc = NA_real_))
    next
  }
  Xtr <- Xtr[, nzv, drop = FALSE]
  Xte <- Xte[, nzv, drop = FALSE]

  # --- Standardize using TRAIN mean/sd (critical for KNN) ---
  mu  <- vapply(Xtr, mean, numeric(1), na.rm = TRUE)
  sdx <- vapply(Xtr, sd,   numeric(1), na.rm = TRUE); sdx[sdx == 0] <- 1
  Xtr_sc <- scale(Xtr, center = mu, scale = sdx)
  Xte_sc <- scale(Xte, center = mu, scale = sdx)

  # --- KNN prediction on TEST ONLY ---
  pred <- knn(train = Xtr_sc, test = Xte_sc, cl = ytr, k = k2)
  acc  <- mean(pred == yte)

  cat("Top", m, "genes  →  K =", k2, "  Test Acc:", 
      sprintf("%.4f", acc), "\n")
  knn_curve <- rbind(knn_curve, data.frame(TopGenes = m, k = k2, 
                                           Test_Acc = acc))
}
```

KNN for loop: k = 7

```{r}
for (m in steps) {
  genes_m <- ranked[1:m]

  Xtr <- as.data.frame(train.data[, genes_m, drop = FALSE])
  Xte <- as.data.frame(test.data[,  genes_m, drop = FALSE])
  ytr <- train.data$Y
  yte <- test.data$Y

  # --- Impute NAs with TRAIN medians (per feature) ---
  for (nm in colnames(Xtr)) {
    med <- median(Xtr[[nm]], na.rm = TRUE)
    if (is.finite(med)) {
      Xtr[[nm]][is.na(Xtr[[nm]])] <- med
      Xte[[nm]][is.na(Xte[[nm]])] <- med
    }
  }

  # --- Drop zero-variance columns (after impute) ---
  nzv <- vapply(Xtr, function(x) length(unique(na.omit(x))) > 1, logical(1))
  if (!any(nzv)) {
    knn_curve <- rbind(knn_curve, data.frame(TopGenes = m, k = k3, 
                                             Test_Acc = NA_real_))
    next
  }
  Xtr <- Xtr[, nzv, drop = FALSE]
  Xte <- Xte[, nzv, drop = FALSE]

  # --- Standardize using TRAIN mean/sd (critical for KNN) ---
  mu  <- vapply(Xtr, mean, numeric(1), na.rm = TRUE)
  sdx <- vapply(Xtr, sd,   numeric(1), na.rm = TRUE); sdx[sdx == 0] <- 1
  Xtr_sc <- scale(Xtr, center = mu, scale = sdx)
  Xte_sc <- scale(Xte, center = mu, scale = sdx)

  # --- KNN prediction on TEST ONLY ---
  pred <- knn(train = Xtr_sc, test = Xte_sc, cl = ytr, k = k3)
  acc  <- mean(pred == yte)

  cat("Top", m, "genes  →  K =", k3, "  Test Acc:", 
      sprintf("%.4f", acc), "\n")
  knn_curve <- rbind(knn_curve, data.frame(TopGenes = m, k = k3, 
                                           Test_Acc = acc))
}
```

## Regression Tree

Prepping for regression tree

```{r}
train.data$Y <- factor(train.data$Y, levels = c(0,1))
test.data$Y  <- factor(test.data$Y,  levels = c(0,1))

# helper
max_k <- min(37L, length(ranked))
if (max_k < 5L) max_k <- length(ranked)
steps <- seq(5L, max_k, by = 5L)
if (tail(steps, 1) != max_k) steps <- c(steps, max_k)

impute_from_train <- function(Xtr, Xte) {
  for (nm in colnames(Xtr)) {
    med <- median(Xtr[[nm]], na.rm = TRUE)
    if (is.finite(med)) {
      Xtr[[nm]][is.na(Xtr[[nm]])] <- med
      if (nm %in% colnames(Xte)) Xte[[nm]][is.na(Xte[[nm]])] <- med
    }
  }
  list(Xtr = Xtr, Xte = Xte)
}

# storage
tree_curve  <- data.frame(TopGenes = integer(), Test_Acc = numeric())
tree_models <- vector("list", length(steps))
names(tree_models) <- paste0("top_", steps)
```

For loop: Need to debug

```{r}
for (s in seq_along(steps)) {
  k <- steps[s]

  ## 0) pick cumulative genes, but only those present in BOTH train & test
  genes_k <- ranked[1:k]
  genes_k <- intersect(genes_k, intersect(names(train.data), names(test.data)))
  if (length(genes_k) == 0L) {
    warning("No overlapping genes at top_", k)
    tree_curve <- rbind(tree_curve, data.frame(TopGenes = k, Test_Error = NA_real_))
    next
  }

  ## 1) extract predictors
  Xtr <- as.data.frame(train.data[, genes_k, drop = FALSE])
  Xte <- as.data.frame(test.data[,  genes_k, drop = FALSE])

  ## 2) impute test from TRAIN medians (no leakage)
  tmp <- impute_from_train(Xtr, Xte); Xtr <- tmp$Xtr; Xte <- tmp$Xte

  ## 3) create ONE canonical safe-name map from original genes_k
  safe_names <- make.names(genes_k, unique = TRUE)
  colnames(Xtr) <- safe_names
  colnames(Xte) <- safe_names

  ## 4) build modeling frames AFTER renaming, using the SAME columns/order
  dat_tr <- data.frame(Y = train.data$Y, Xtr[, safe_names, drop = FALSE], check.names = FALSE)
  dat_te <- data.frame(Y = test.data$Y,  Xte[, safe_names, drop = FALSE], check.names = FALSE)

  ## 5) build formula from the SAME names
  formula_tree <- as.formula(paste("Y ~", paste(safe_names, collapse = " + ")))

  ## 6) fit tree (guard errors)
  fit <- tryCatch(tree::tree(formula_tree, data = dat_tr),
                  error = function(e){ warning("top_", k, ": ", e$message); NULL })
  if (is.null(fit)) {
    tree_curve <- rbind(tree_curve, data.frame(TopGenes = k, Test_Error = NA_real_))
    next
  }
  tree_models[[s]] <- fit

  ## 7) align TEST to exactly what the model expects (term labels), then predict
  vars_needed <- attr(fit$terms, "term.labels")

  ## debug guards (uncomment if needed)
  # cat("vars_needed: ", paste(vars_needed, collapse=", "), "\n")
  # cat("missing in dat_te: ", paste(setdiff(vars_needed, names(dat_te)), collapse=", "), "\n")

  new_te <- dat_te[, vars_needed, drop = FALSE]   # exact names & order
  pred   <- predict(fit, newdata = new_te, type = "class")

  ## 8) test error (misclassification rate)
  test_error <- mean(pred != dat_te$Y)
  cat("Top", k, "→ Test Error:", sprintf("%.4f", test_error), "\n")

  tree_curve <- rbind(tree_curve, data.frame(TopGenes = k, Test_Error = test_error))
}
```


```{r, ref.label=knitr::all_labels(), echo = TRUE, eval = FALSE}
```