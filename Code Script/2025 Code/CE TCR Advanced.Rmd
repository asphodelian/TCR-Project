---
title: "CE TCR Advanced"
author: "Gabrielle Salamanca"
date: "October 25, 2025"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Libraries

```{r}
# data manipulation
library(dplyr)
library(psych)
library(readr)
library(readxl)
library(tidyr)

# visualize
library(factoextra)
library(ggfortify)
library(ggplot2)
library(gridExtra)

# techniques
library(brglm2) # bias-reduced log regress
library(caret) # data partition, CV
library(class) # KNN 
library(gbm) # boosting
library(MASS) # QDA & LDA
library(randomForest) # bag, rand forest
library(rpart) # class tree
library(stats)
library(tree) # regression tree
```

## Dataset

We read in the dataset, and replace a handful of NAs. The HD patients' Y and Y1 were filled in with "healthy", because Professor Tao confirmed they were healthy patients. Row 22 was removed, because there was confirmation that it didn't have any results, even in its own ID.

```{r}
gene <- read_excel("D:/Coding/R Storage/Summer TCR Project/TCR Datasets/2025/fullgenes.xlsx")

cat("The dimensions of the dataset is:")
dim(gene)

cat("\nAre there any NAs in the Y column?")
table(is.na(gene$Y))
cat("\nAre there NAs in the Y1 column?")
table(is.na(gene$Y1))

cat("\nWe remove row 22, to then have the dimensions:")
genedit <- gene[-22,]
dim(genedit)

cat("\n")

for (lab in intersect(c("Y","Y1"), names(genedit))) {
  genedit[[lab]][is.na(genedit[[lab]])] <- "healthy"
}

cat("After replacing NAs with the healthy tag, are there any lingering NAs in the Y column?")
table(is.na(genedit$Y))
cat("\nin the Y1 column?")
table(is.na(genedit$Y1))
```

## Training and Test Set

```{r}
set.seed(895)

train <- sample(1:nrow(genedit),0.8*nrow(genedit))
train.data <- genedit[train,]
test.data <- genedit[-train,]

cat("The dimensions of the training set is:", dim(train.data), "\n")
cat("The dimensions of the test is:", dim(test.data), "\n")

# turn Y binary
train.data$Y <- as.numeric(ifelse(train.data$Y == "disease", 1, 0))
test.data$Y  <- as.numeric(ifelse(test.data$Y  == "disease", 1, 0))
```

## Finding the Significant Genes

Prepping for the for loop:

```{r}
col <- ncol(train.data)
ycol <- match("Y", names(train.data))
gene_idx  <- 2:(col - 2)
gene.name <- names(train.data)[gene_idx]
pvalue <- numeric(length(gene_idx))
```

For loop to find the significant genes

```{r}
for (i in seq_along(gene_idx))
{
  gene_name <- gene.name[i]
  Xi <- train.data[, gene_idx[i], drop = FALSE]
  names(Xi) <- gene_name  # set column name to the gene
  
  dat <- data.frame(Y = train.data[[ycol]], Xi, 
                    check.names = FALSE)
  glm.fit <- glm(Y ~ ., data = dat, family = binomial())
  pvalue[i] <- coef(summary(glm.fit))[2, 4]
}
```

Create the results table and sort by significance

```{r}
# Combine results into a nice table:
results <- data.frame(Gene = gene.name, P_value = pvalue)

# Sort by significance
results <- results[order(results$P_value), ]
head(results)
```

Get only the genes that have a p-value less than 0.05, and make sure the genes are in both the training and test data

```{r}
alpha <- results[results$P_value < 0.05,]
cat("The dimensions of the significant genes (alpha) dataset is:")
dim(alpha)

ranked <- alpha$Gene
ranked <- intersect(ranked, intersect(names(train.data), names(test.data)))
```

## Classification Tree

Prep for the true classification tree

```{r}
train.data$Y <- factor(train.data$Y, levels = c(0,1))
test.data$Y  <- factor(test.data$Y,  levels = levels(train.data$Y))

# steps
max_k <- min(37L, length(ranked))
if (max_k < 5L) max_k <- length(ranked)
steps <- seq(5L, max_k, by = 5L)
if (tail(steps, 1) != max_k) steps <- c(steps, max_k)

# helper
impute_from_train <- function(Xtr, Xte) {
  for (nm in colnames(Xtr)) {
    med <- suppressWarnings(median(Xtr[[nm]], na.rm = TRUE))
    if (is.finite(med)) {
      Xtr[[nm]][is.na(Xtr[[nm]])] <- med
      Xte[[nm]][is.na(Xte[[nm]])] <- med
    }
  }
  list(Xtr = Xtr, Xte = Xte)
}

# storage
tree_curve <- data.frame(TopGenes = integer(), Test_Error = numeric())
```

For loop

```{r}
for (k in steps) {
  genes_k <- ranked[1:k]
  genes_k <- intersect(genes_k, intersect(names(train.data), names(test.data)))
  if (!length(genes_k)) {
    tree_curve <- rbind(tree_curve, data.frame(TopGenes = k, Test_Acc = NA_real_))
    next
  }

  # 1) Extract predictors
  Xtr <- as.data.frame(train.data[, genes_k, drop = FALSE])
  Xte <- as.data.frame(test.data[,  genes_k, drop = FALSE])

  # 2) Impute TEST from TRAIN medians
  for (nm in colnames(Xtr)) {
    med <- suppressWarnings(median(Xtr[[nm]], na.rm = TRUE))
    if (is.finite(med)) {
      Xtr[[nm]][is.na(Xtr[[nm]])] <- med
      Xte[[nm]][is.na(Xte[[nm]])] <- med
    }
  }

  # 3) ONE canonical name map; apply to BOTH sets BEFORE building data frames
  safe_names <- make.names(genes_k, unique = TRUE)
  colnames(Xtr) <- safe_names
  colnames(Xte) <- safe_names

  # 4) Modeling frames (same columns & order)
  dat_tr <- data.frame(Y = factor(train.data$Y, levels = c(0,1)),
                       Xtr[, safe_names, drop = FALSE],
                       check.names = FALSE)
  dat_te <- data.frame(Y = factor(test.data$Y, levels = c(0,1)),
                       Xte[, safe_names, drop = FALSE],
                       check.names = FALSE)

  # 5) Formula from the SAME names (avoid paste() pitfalls)
  form_tree <- reformulate(termlabels = safe_names, response = "Y")

  # 6) Fit + prune
  fit <- rpart(form_tree, data = dat_tr, method = "class",
               control = rpart.control(cp = 0.001, minsplit = 10, xval = 10))

  cpt <- fit$cptable
  imin <- which.min(replace(cpt[, "xerror"], is.na(cpt[, "xerror"]), Inf))
  cp_opt <- cpt[imin, "CP"]
  fit_pruned <- prune(fit, cp = cp_opt)

  # 7) Align TEST to what the model expects (names & order)
  vars_needed <- attr(fit_pruned$terms, "term.labels")   # should equal safe_names
  # quick guard: must be empty
  if (length(setdiff(vars_needed, names(dat_te)))) {
    stop("Missing in test: ", paste(setdiff(vars_needed, names(dat_te)), collapse = ", "))
  }
  new_te <- dat_te[, vars_needed, drop = FALSE]
  # ensure identical name vector
  stopifnot(identical(names(new_te), vars_needed))

  # 8) Predict & TEST ACCURACY
  pred <- predict(fit_pruned, newdata = new_te, type = "class")
  test_acc <- mean(pred == dat_te$Y)

  cat("Top", k, "genes → Test Accuracy:", sprintf("%.4f", test_acc), "\n")
  tree_curve <- rbind(tree_curve, data.frame(TopGenes = k, Test_Acc = test_acc))
}
```

## Bagging

Prep for Bagging

```{r}
# storage
bag_curve <- data.frame(TopGenes = integer(), Test_Error = numeric())
```

For loop

```{r}
for (k in steps) {
  genes_k <- ranked[1:k]

  # Extract predictors
  Xtr <- as.data.frame(train.data[, genes_k, drop = FALSE])
  Xte <- as.data.frame(test.data[,  genes_k, drop = FALSE])

  # Impute NAs
  tmp <- impute_from_train(Xtr, Xte); Xtr <- tmp$Xtr; Xte <- tmp$Xte

  # Sanitize names consistently
  safe_names <- make.names(genes_k, unique = TRUE)
  colnames(Xtr) <- safe_names
  colnames(Xte) <- safe_names

  # Modeling frames
  dat_tr <- data.frame(Y = train.data$Y, Xtr, check.names = FALSE)
  dat_te <- data.frame(Y = test.data$Y,  Xte, check.names = FALSE)

  # Bagging = randomForest with mtry = p (all predictors)
  form_bag <- reformulate(termlabels = safe_names, response = "Y")
  bag.fit <- randomForest(
    form_bag, data = dat_tr,
    mtry = length(safe_names),     # <- bagging
    ntree = 500,
    importance = FALSE,
    nodesize = 20
  )

  # Predict on TEST and compute TEST ACCURACY
  pred <- predict(bag.fit, newdata = dat_te, type = "class")
  test_acc <- mean(pred == dat_te$Y)

  # Print only accuracy
  cat("Top", k, "genes → Test Accuracy:", sprintf("%.4f", test_acc), "\n")

  # Store (optional)
  bag_curve <- rbind(bag_curve, data.frame(TopGenes = k, Test_Acc = test_acc))
}
```

Tree node size test

```{r}
# grid of nodesizes to test
nodesize_grid <- c(1, 3, 5, 10, 20)

bag_size_curve <- data.frame(nodesize = integer(), Test_Acc = numeric())

for (ns in nodesize_grid) {
  bag.fit <- randomForest(
    Y ~ ., data = dat_tr,
    mtry = ncol(dat_tr) - 1,    # all predictors
    ntree = 500,
    nodesize = ns
  )

  pred <- predict(bag.fit, newdata = dat_te, type = "class")
  test_acc <- mean(pred == dat_te$Y)
  cat("nodesize =", ns, "→ Test Accuracy:", sprintf("%.4f", test_acc), "\n")

  bag_size_curve <- rbind(bag_size_curve,
                          data.frame(nodesize = ns, Test_Acc = test_acc))
}
```


## Random Forest

Prep

```{r}
rf_curve <- data.frame(TopGenes = integer(), Test_Acc = numeric())
```

for loop

```{r}
for (k in steps) {
  genes_k <- ranked[1:k]

  # Extract predictors
  Xtr <- as.data.frame(train.data[, genes_k, drop = FALSE])
  Xte <- as.data.frame(test.data[,  genes_k, drop = FALSE])

  # Impute NAs
  tmp <- impute_from_train(Xtr, Xte); Xtr <- tmp$Xtr; Xte <- tmp$Xte

  # Sanitize names consistently
  safe_names <- make.names(genes_k, unique = TRUE)
  colnames(Xtr) <- safe_names
  colnames(Xte) <- safe_names

  # Modeling frames
  dat_tr <- data.frame(Y = train.data$Y, Xtr, check.names = FALSE)
  dat_te <- data.frame(Y = test.data$Y,  Xte, check.names = FALSE)

  # Random Forest: mtry = floor(sqrt(p)) for classification
  p <- length(safe_names)
  mtry_val <- max(1L, floor(sqrt(p)))

  form_rf <- reformulate(termlabels = safe_names, response = "Y")
  rf.fit <- randomForest(
    form_rf, data = dat_tr,
    mtry = mtry_val,
    ntree = 500,
    importance = TRUE
  )

  # Predict on TEST and compute TEST ACCURACY
  pred <- predict(rf.fit, newdata = dat_te, type = "class")
  test_acc <- mean(pred == dat_te$Y)

  # Print only accuracy
  cat("Top ", k, " genes → Test Accuracy: ", sprintf("%.4f", test_acc),
      " (mtry = ", mtry_val, ", ntree = 500)\n", sep="")

  # Store
  rf_curve <- rbind(rf_curve, data.frame(TopGenes = k, Test_Acc = test_acc))
}

```



```{r, ref.label=knitr::all_labels(), echo = TRUE, eval = FALSE}
```